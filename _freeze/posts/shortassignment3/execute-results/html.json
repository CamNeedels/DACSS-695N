{
  "hash": "60d314daa54c2c21f2a5e8aa6c52b52f",
  "result": {
    "markdown": "---\ntitle: \"Short Assignment 3\"\nsubtitle: \"DACSS 695N Social Network Analysis\"\nauthor: \"E. Song/ Cameron Needels\"\ndate: \"February 24, 2024\"\nformat: \n  html:\n    toc: true\n    toc-depth: 2\n    toc-title: Contents\n    toc-location: left\n    code-fold: false\n    html-math-method: katex\n    theme: flatly\n    smooth-scroll: true\n    link-external-icon: true\n    link-external-newwindow: true\n    citations-hover: true\n    footnotes-hover: true\n    font-size: 80%\neditor: visual\n---\n\n\n<!--ATTENTION!-->\n\n\n```{=html}\n<!--Please knit this qmd to an html and submit both qmd and html files. Add your name (next to mine) in the ymal above. Also, don't forget the last part of this tutorial (i.e., Problems 4 ~ 7) has QUESTIONS you have to solve! Enjoy. This assignment is DUE March 3 @ 11:59 pm.\n-->\n```\n\n# Problem 1\n\nBelow are social network data collected from members of a book club at a university. The students were asked to rate ‘how much they interacted online’ with the other students over the last two weeks on a five-point Likert scale with 1 being ‘very little’ and 5 being ‘a great deal.’\n\na.  Enter the data in a spreadsheet, import it, and create a statnet network object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# run if necessary: rm(list=ls())\ngetwd()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"C:/Users/Needels/Desktop/DACCS/A/DACSS 695N/DACSS 695N Blog/posts\"\n```\n:::\n\n```{.r .cell-code}\n# setwd()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbookclub.el <- read.csv(\"shortassignment3_q1_bookclub.csv\",\n                        header = FALSE)\nhead(bookclub.el)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    V1     V2 V3\n1 Mark   Gene  5\n2 Mark Silvia  4\n3 Mark  Sarah  4\n4 Mark    Tim  2\n5 Gene   Mark  2\n6 Gene Silvia  2\n```\n:::\n\n```{.r .cell-code}\n# creating a statnet object\nlibrary(statnet)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'statnet' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'tergm' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'ergm' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'network' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'networkDynamic' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'ergm.count' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'sna' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'statnet.common' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'tsna' was built under R version 4.2.3\n```\n:::\n\n```{.r .cell-code}\nbookclub.st <- network(bookclub.el,\n                       directed = TRUE)\n\n# check:\nsummary(bookclub.st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 20 \n   missing edges = 0 \n   non-missing edges = 20 \n density = 1 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nEdge attributes:\n\n V3:\n   integer valued attribute\n   20values\n\nNetwork adjacency matrix:\n       Mark Gene Silvia Sarah Tim\nMark      0    1      1     1   1\nGene      1    0      1     1   1\nSilvia    1    1      0     1   1\nSarah     1    1      1     0   1\nTim       1    1      1     1   0\n```\n:::\n\n```{.r .cell-code}\n# Let's check the edge weights are in place properly.\n# with statnet: NETWORKOBJECT[ , ]\nbookclub.st[,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Mark Gene Silvia Sarah Tim\nMark      0    1      1     1   1\nGene      1    0      1     1   1\nSilvia    1    1      0     1   1\nSarah     1    1      1     0   1\nTim       1    1      1     1   0\n```\n:::\n\n```{.r .cell-code}\n# converting to an adjacency matrix.. \n# what's missing here?\n# In statnet edges and edge weights are considered separate. \n# To see a particular weight, use the edge attribute shorthand %e% and \n# to get the full netowrk with weights, use: as.sociomatrix.sna()\n# Note that the network command called the weights by the column name\n# from the input file.\nlist.edge.attributes(bookclub.st)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"na\" \"V3\"\n```\n:::\n\n```{.r .cell-code}\n# the input csv file didn't have no header for the weight,\n# so we have \"V3\" created when it was imported.\n# to see whether it's really associated with our network object\nbookclub.st %e% \"V3\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 5 4 4 2 2 2 3 4 2 2 4 4 2 1 2 4 1 3 2 4\n```\n:::\n\n```{.r .cell-code}\n# Yes!\n\n# now let's create an adjacency matrix with the weights:\nas.sociomatrix.sna(bookclub.st, \"V3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Mark Gene Silvia Sarah Tim\nMark      0    5      4     4   2\nGene      2    0      2     3   4\nSilvia    2    2      0     4   4\nSarah     2    1      2     0   4\nTim       1    3      2     4   0\n```\n:::\n\n```{.r .cell-code}\n# If you like, we can change rename the edge attribute name in multiple ways:\nbookclub.st %e% \"freq\" <- bookclub.st %e% \"V3\"\n\nidentical(bookclub.st %e% \"freq\", bookclub.st %e% \"V3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Symmetrize matrix\n\n# sna offers a handy function: symmetrize(graph, rule)\n# 4 rules:\n## upper: copy the upper triangle over the lower triangle\n## lower: Copy the lower triangle over the upper triangle\n## strong: i <--> j iff i -> j AND j -> i\n## weak: i <--> j iff i -> j OR j -> i\n\nsymmetrize(bookclub.st, rule = \"strong\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    1    1    1\n[2,]    1    0    1    1    1\n[3,]    1    1    0    1    1\n[4,]    1    1    1    0    1\n[5,]    1    1    1    1    0\n```\n:::\n\n```{.r .cell-code}\nsymmetrize(bookclub.st, rule = \"weak\") # no difference, Why?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    1    1    1\n[2,]    1    0    1    1    1\n[3,]    1    1    0    1    1\n[4,]    1    1    1    0    1\n[5,]    1    1    1    1    0\n```\n:::\n\n```{.r .cell-code}\n# Because all five students are communicated with all others!\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's play with some other approaches:\n# First, let's extract a weighteed matrix from bookclub.st:\nbookclub.mw <- as.matrix(bookclub.st, attrname = \"freq\")\nbookclub.mw\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Mark Gene Silvia Sarah Tim\nMark      0    5      4     4   2\nGene      2    0      2     3   4\nSilvia    2    2      0     4   4\nSarah     2    1      2     0   4\nTim       1    3      2     4   0\n```\n:::\n\n```{.r .cell-code}\n# OR\nbookclub.mw2 <- as.sociomatrix.sna(bookclub.st, \"freq\")\nbookclub.mw2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Mark Gene Silvia Sarah Tim\nMark      0    5      4     4   2\nGene      2    0      2     3   4\nSilvia    2    2      0     4   4\nSarah     2    1      2     0   4\nTim       1    3      2     4   0\n```\n:::\n\n```{.r .cell-code}\n# Now, let's dichotomize the data using greater than 3:\nbookclub.m.dicho <- ifelse(bookclub.mw >= 3, 1, 0)\nbookclub.m.dicho\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Mark Gene Silvia Sarah Tim\nMark      0    1      1     1   0\nGene      0    0      0     1   1\nSilvia    0    0      0     1   1\nSarah     0    0      0     0   1\nTim       0    1      0     1   0\n```\n:::\n\n```{.r .cell-code}\n# wow. now we have a quite different matrix.\n```\n:::\n\n\n# Problem 2\n\nDemographic and attribute data were also collected. Data include age, gender and attitude towards premarital sex on a Likert scale from 1 to 5 (with 1 being completely against and 5 being completely in favor).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes <- data.frame(\n  name = c(\"Mark\", \"Gene\", \"Silvia\", \"Sarah\", \"Tim\"),\n  age = c(18, 25, 19, 21, 22),\n  gender = c(1, 1, 2, 2, 1), # 1: male, 2: female\n  prems = c(4, 2, 2, 5, 1) # attitude towards premarital sex (1 to 5)\n)\n\nhead(attributes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    name age gender prems\n1   Mark  18      1     4\n2   Gene  25      1     2\n3 Silvia  19      2     2\n4  Sarah  21      2     5\n5    Tim  22      1     1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's add these attributes to the network object:\n# You could take different approaches!\n# Let's create from scratch\n## using bookclub.el (edgelist) and attributes\n\n## Let's create an attribute \"list\" object\nattribute_list <- do.call(list, attributes)\nhead(attribute_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$name\n[1] \"Mark\"   \"Gene\"   \"Silvia\" \"Sarah\"  \"Tim\"   \n\n$age\n[1] 18 25 19 21 22\n\n$gender\n[1] 1 1 2 2 1\n\n$prems\n[1] 4 2 2 5 1\n```\n:::\n\n```{.r .cell-code}\nbookclub.st.3 <- network(bookclub.el,\n                         directed = TRUE,\n                         matrix.type = \"edgelist\",\n                         vertex.attr = attribute_list)\nbookclub.st.3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Network attributes:\n  vertices = 5 \n  directed = TRUE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 20 \n    missing edges= 0 \n    non-missing edges= 20 \n\n Vertex attribute names: \n    age gender name prems vertex.names \n\n Edge attribute names: \n    V3 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Or, you could add each attribute to the network object\n# now let's use the first network object we created: bookclub.st\n# set.vertex.attribute()\nset.vertex.attribute(bookclub.st,\n                     attrname = \"gender\",\n                     value = attributes$gender)\nbookclub.st %v% \"gender\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 2 2 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Converting attributes into matrix/network\n# Let's put the network objects aside\n# And create a slightly different type of matrix\n# by converting a vertex attribute into a network\n# let's start with gender\n# 1 for students of the same gender \n# 0 for different gender\n\n# are we going to use\nas.sociomatrix.sna(bookclub.st.3, attr = \"gender\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in as.matrix.network.adjacency(x, attrname = attrname, expand.bipartite\n= expand.bipartite, : There is no edge attribute named gender\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n       Mark Gene Silvia Sarah Tim\nMark      0    1      1     1   1\nGene      1    0      1     1   1\nSilvia    1    1      0     1   1\nSarah     1    1      1     0   1\nTim       1    1      1     1   0\n```\n:::\n\n```{.r .cell-code}\n# well.. we can't!\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Let's then do it manually:\n# first create an empty matrix\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'tidyverse' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'tibble' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'purrr' was built under R version 4.2.3\n```\n:::\n\n```{.r .cell-code}\ngender <- attributes %>%\n  select(name, gender) \n\n\ngender\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    name gender\n1   Mark      1\n2   Gene      1\n3 Silvia      2\n4  Sarah      2\n5    Tim      1\n```\n:::\n\n```{.r .cell-code}\n# first create a matrix\ngender.m <- matrix(0, \n                   nrow = nrow(gender),\n                   ncol = nrow(gender))\ndim(gender.m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 5\n```\n:::\n\n```{.r .cell-code}\nfor(i in 1:nrow(gender)){\n  for(j in 1:nrow(gender)){\n    gender.m[i, j] <- ifelse(gender$gender[i] == gender$gender[j], 1, 0)\n  }\n}\n\ndiag(gender.m) <- 0\n\ncolnames(gender.m) <- gender$name\nrownames(gender.m) <- gender$name\n\ngender.m\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Mark Gene Silvia Sarah Tim\nMark      0    1      0     0   1\nGene      1    0      0     0   1\nSilvia    0    0      0     1   0\nSarah     0    0      1     0   0\nTim       1    1      0     0   0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# one more: let's do the same procedure\n# with a continuous variable: age\n# by taking absolute difference\n\nage <- attributes %>%\n  select(name, age) \n\n\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    name age\n1   Mark  18\n2   Gene  25\n3 Silvia  19\n4  Sarah  21\n5    Tim  22\n```\n:::\n\n```{.r .cell-code}\n# first create a matrix\nage.abd.m <- matrix(0, \n                   nrow = nrow(age),\n                   ncol = nrow(age))\ndim(age.abd.m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 5\n```\n:::\n\n```{.r .cell-code}\n# use abs() to compute absolute difference\nfor(i in 1:nrow(age)){\n  for(j in 1:nrow(age)){\n    age.abd.m[i, j] <- abs(age$age[i] - age$age[j])\n    age.abd.m[j, i] <- abs(age$age[j] - age$age[i])\n  }\n}\n\ndiag(gender.m) <- 0\n\ncolnames(age.abd.m) <- age$name\nrownames(age.abd.m) <- age$name\n\nage.abd.m\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Mark Gene Silvia Sarah Tim\nMark      0    7      1     3   4\nGene      7    0      6     4   3\nSilvia    1    6      0     2   3\nSarah     3    4      2     0   1\nTim       4    3      3     1   0\n```\n:::\n\n```{.r .cell-code}\n# Let's check all values are correct\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    name age\n1   Mark  18\n2   Gene  25\n3 Silvia  19\n4  Sarah  21\n5    Tim  22\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Practice: Convert the Attitude variable into a matrix using the absolute difference and create a network. What do the values represent?\n```\n:::\n\n\n# Problem 3\n\nIn addition to the one-mode social network data above, two-mode data were also collected on which university events each had attended over the last six months. Here are the data:\n\n-   Mark went to Hawking's Lecture.\n-   Gene went to Hawking's Lecture and Spring Concert.\n-   Silvia went to Hawking's Lecture, Halloween Event, and Fall Dance.\n-   Sarah went to Hawking's Lecture, Halloween Event, Spring Concert, and Fall Dance.\n-   Tim went to Halloween Event, Spring Concert, and Fall Dance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Format the data as a spreadsheet file using a nodelist format, and save as a CSV file, then read into R.\nbookclub.tmode <- read_csv(\"shortassignment_twomode.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 5 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): Name, Event1, Event2, Event3, Event4\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nbookclub.tmode\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 5\n  Name   Event1    Event2    Event3 Event4\n  <chr>  <chr>     <chr>     <chr>  <chr> \n1 Mark   lecture   <NA>      <NA>   <NA>  \n2 Gene   lecture   spring    <NA>   <NA>  \n3 Silvia lecture   halloween dance  <NA>  \n4 Sarah  lecture   halloween spring dance \n5 Tim    halloween spring    dance  <NA>  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# okay. what should be the next step?\n# data wrangling\nbookclub.tmode.el <- pivot_longer(bookclub.tmode,\n                                  cols = starts_with(\"Event\"),\n                                  names_to = \"Event\",\n                                  values_to = \"events\"\n                                  ) %>%\n                      select(-Event) %>%\n                      filter(!is.na(events))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good! let's create a network object\nbookclub.tm.st <- as.network(bookclub.tmode.el,\n                             directed = FALSE,\n                             bipartite = TRUE) # logical\n\nbookclub.tm.st\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Network attributes:\n  vertices = 9 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = 5 \n  total edges= 13 \n    missing edges= 0 \n    non-missing edges= 13 \n\n Vertex attribute names: \n    vertex.names \n\nNo edge attributes\n```\n:::\n\n```{.r .cell-code}\nbookclub.tm.st %v% \"vertex.names\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Mark\"      \"Gene\"      \"Silvia\"    \"Sarah\"     \"Tim\"       \"lecture\"  \n[7] \"spring\"    \"halloween\" \"dance\"    \n```\n:::\n\n```{.r .cell-code}\nbookclub.incidence.m <- bookclub.tm.st[,]\n\nbookclub.tmode\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 5\n  Name   Event1    Event2    Event3 Event4\n  <chr>  <chr>     <chr>     <chr>  <chr> \n1 Mark   lecture   <NA>      <NA>   <NA>  \n2 Gene   lecture   spring    <NA>   <NA>  \n3 Silvia lecture   halloween dance  <NA>  \n4 Sarah  lecture   halloween spring dance \n5 Tim    halloween spring    dance  <NA>  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# using igraph\ndetach(package:statnet)\nlibrary(igraph)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'igraph' was built under R version 4.2.3\n```\n:::\n\n```{.r .cell-code}\n# multiple ways are available\n# 1. use graph.data.frame (if you have an edgelist)\nbookclub.tm.ig <- graph.data.frame(bookclub.tmode.el,\n                                   directed = FALSE)\n# and remember: igraph doesn't automatically recotnize two-mode networks\n# it's necessary to tell igraph that two types of nodes are in the data\n# use bipartite.mapping()\n\nbipartite.mapping(bookclub.tm.ig)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$res\n[1] TRUE\n\n$type\n[1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\nnames(bipartite.mapping(bookclub.tm.ig))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"res\"  \"type\"\n```\n:::\n\n```{.r .cell-code}\nV(bookclub.tm.ig)$type <- bipartite.mapping(bookclub.tm.ig)$type\n# type == FALSE: node set 1 (i.e., students)\n# type == TRUE: node set 2 (i.e., events)\n\n\n# 2. or if you have an incidence matrix\n## use graph_from_incidence_matrix\nbookclub.tm.ig2 <- graph_from_incidence_matrix(incidence = bookclub.incidence.m,\n                                               mode = \"all\")\n\nbookclub.tm.ig2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH fd6a804 UN-B 9 13 -- \n+ attr: type (v/l), name (v/c)\n+ edges from fd6a804 (vertex names):\n [1] Mark  --lecture   Gene  --lecture   Gene  --spring    Silvia--lecture  \n [5] Silvia--halloween Silvia--dance     Sarah --lecture   Sarah --spring   \n [9] Sarah --halloween Sarah --dance     Tim   --spring    Tim   --halloween\n[13] Tim   --dance    \n```\n:::\n\n```{.r .cell-code}\nV(bookclub.tm.ig2)$type # automatically created!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\n# take a look at this: this is a bipartite matrix!\nbookclub.tm.ig2[,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n9 x 9 sparse Matrix of class \"dgCMatrix\"\n          Mark Gene Silvia Sarah Tim lecture spring halloween dance\nMark         .    .      .     .   .       1      .         .     .\nGene         .    .      .     .   .       1      1         .     .\nSilvia       .    .      .     .   .       1      .         1     1\nSarah        .    .      .     .   .       1      1         1     1\nTim          .    .      .     .   .       .      1         1     1\nlecture      1    1      1     1   .       .      .         .     .\nspring       .    1      .     1   1       .      .         .     .\nhalloween    .    .      1     1   1       .      .         .     .\ndance        .    .      1     1   1       .      .         .     .\n```\n:::\n\n```{.r .cell-code}\n# let's go back to statnet\ndetach(package:igraph)\nlibrary(statnet)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'statnet' was built under R version 4.2.3\n```\n:::\n:::\n\n\n# Problem 4\n\nFinally, the students were asked who talks to whom about school-related matters.\n\n-   Mark reports he talks to Gene, Silvia, and Sarah\n-   Gene reports he talks to Tim.\n-   Silvia reports she talks to Tim and Sarah.\n-   Sarah reports she talks to Tim.\n-   Tim reports he talks to Sarah.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assignment:\n# Q1. Format the data as a spreadsheet file the edgelist format. Import the CSV file into R.\ndetach(package:statnet)\nlibrary(igraph)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'igraph' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'igraph'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:lubridate':\n\n    %--%, union\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:dplyr':\n\n    as_data_frame, groups, union\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:purrr':\n\n    compose, simplify\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:tidyr':\n\n    crossing\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:tibble':\n\n    as_data_frame\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:sna':\n\n    betweenness, bonpow, closeness, components, degree, dyad.census,\n    evcent, hierarchy, is.connected, neighborhood, triad.census\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:network':\n\n    %c%, %s%, add.edges, add.vertices, delete.edges, delete.vertices,\n    get.edge.attribute, get.edges, get.vertex.attribute, is.bipartite,\n    is.directed, list.edge.attributes, list.vertex.attributes,\n    set.edge.attribute, set.vertex.attribute\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:base':\n\n    union\n```\n:::\n\n```{.r .cell-code}\nstudents_talk <- read.csv(\"dacss695n_prob4.csv\",\n                        header = FALSE)\nstudents_talk <- network(bookclub.el,\n                       directed = TRUE)\n\nas.sociomatrix.sna(students_talk)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Mark Gene Silvia Sarah Tim\nMark      0    1      1     1   1\nGene      1    0      1     1   1\nSilvia    1    1      0     1   1\nSarah     1    1      1     0   1\nTim       1    1      1     1   0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assignment:\n# Q2. Symmetrize the network using the 'OR' option\n\n\nsymmetrize(students_talk, rule = \"weak\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    1    1    1    1\n[2,]    1    0    1    1    1\n[3,]    1    1    0    1    1\n[4,]    1    1    1    0    1\n[5,]    1    1    1    1    0\n```\n:::\n\n```{.r .cell-code}\nsummary(students_talk)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNetwork attributes:\n  vertices = 5\n  directed = TRUE\n  hyper = FALSE\n  loops = FALSE\n  multiple = FALSE\n  bipartite = FALSE\n total edges = 20 \n   missing edges = 0 \n   non-missing edges = 20 \n density = 1 \n\nVertex attributes:\n  vertex.names:\n   character valued attribute\n   5 valid vertex names\n\nEdge attributes:\n\n V3:\n   integer valued attribute\n   20values\n\nNetwork adjacency matrix:\n       Mark Gene Silvia Sarah Tim\nMark      0    1      1     1   1\nGene      1    0      1     1   1\nSilvia    1    1      0     1   1\nSarah     1    1      1     0   1\nTim       1    1      1     1   0\n```\n:::\n:::\n\n\n# Problem 5\n\nImagine you would want to combine the dichotimized online interaction network (Problem 1) and the face-to-face talking network (Problem 4) into one matrix.\n\na.  How would you go about making sure you are able to distinguish between ties where\n\n-   \n\n    (a) members only talk face-to-face, but do not interact online\n\n-   I would make that number 3 because it is a significant relationship but not the strongest\n\n```         \n(b) members only interact online, but not face-to-face,\n```\n\n-   I would make this 2 because its a connection but they are not as strong as in person.\n\n```         \n(c) members do both, and\n```\n\n-   4 this would be the strongest relationship by far and the most significant\n\n```         \n(d) members do neither?\n\n    1 this is the weakest connection by far\n```\n\nUse R to answer!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(statnet)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'statnet' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n'statnet' 2019.6 (2019-06-13), part of the Statnet Project\n* 'news(package=\"statnet\")' for changes since last version\n* 'citation(\"statnet\")' for citation information\n* 'https://statnet.org' for help, support, and other information\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nunable to reach CRAN\n```\n:::\n\n```{.r .cell-code}\n# Load the datasets from previous problems\nonline_interact <- as.sociomatrix.sna(bookclub.st, attr = \"freq\")\nface_to_face <- as.sociomatrix.sna(students_talk)\n\n# Combine the two into one matrix\ncombined_network <- online_interact + face_to_face\n\n# Define thresholds for distinguishing between different types of ties\nonly_online_threshold <- 1 \nonly_face_to_face_threshold <- 1\n\n# Create a new matrix to store the types of ties\ntie_types <- matrix(0, nrow = nrow(combined_network), ncol = ncol(combined_network))\n\n# Assign values to distinguish between different types of ties\ntie_types[combined_network < only_online_threshold] <- 2  # Members only interact online\ntie_types[combined_network == only_face_to_face_threshold] <- 3  # Members only talk face-to-face\ntie_types[combined_network > only_face_to_face_threshold & combined_network > only_online_threshold] <- 4  # Members do both\ntie_types[combined_network == 0] <- 1  # Members do neither\n\n# Display the combined matrix with tie types\ntie_types\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    4    4    4\n[2,]    4    1    4    4    4\n[3,]    4    4    1    4    4\n[4,]    4    4    4    1    4\n[5,]    4    4    4    4    1\n```\n:::\n:::\n\n\n# Problem 6\n\nSuppose you asked each child in a school with 783 students to name their three best friends. How would you store that data? What if you were to ask them to rank their three choices from closest (1) to least close (3)? How would you store the data?\n\nEach student would be a node in the graph. For each of those students there will be directed egdes to the friends they named. I would store it in an adjacency matrix. If I had to ask them to rank their friends I would make a variable that would indicate their rank (1,2, or 3) and this would make it so each edge will have a weight.\n\n# Problem 7\n\nCheck the [IMDb Non-Commercial Datasets](https://developer.imdb.com/non-commercial-datasets/). Read carefully the page and think about potential networks you'd like to construct. Discuss the following items:\n\n-   Node set(s)\n    -   **Movies/TV Shows (Titles)**: Each title will be represented as a node in the network.\n    -   **Genres**: Genres of movies/TV shows could also be represented as nodes.\n-   Relationships of interest\n    -   **Genre Relationship**: Connects titles with their corresponding genres.\n    -   **Similarity Relationship**: Based on the ratings, we can establish a similarity measure between titles.\n-   Potential research questions: one or two questions should be enough.\n    -   Does the average rating of a title correlate with the amount of votes a show receives?\n    -   Do similar titles receive similar rating scores?\n    -   Does a certain genre receive better ratings than the other genres?\n-   Indicate which files you need to download and explain why.\n    -   **title.ratings.tsv.gz**: This file contains the necessary information about the titles, including their unique identifier, average ratings, and the number of votes.\n    -   **title.basics.tsv.gz**: The title, genre, and the year of release are all useful and necessary pieces of information.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}